<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Technical | ifdattic]]></title>
  <link href="http://ifdattic.com/categories/technical/atom.xml" rel="self"/>
  <link href="http://ifdattic.com/"/>
  <updated>2015-05-20T13:54:19+03:00</updated>
  <id>http://ifdattic.com/</id>
  <author>
    <name><![CDATA[Andrew Marcinkevičius]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Spy Test Double Using Prophecy]]></title>
    <link href="http://ifdattic.com/spy-test-double-using-prophecy"/>
    <updated>2015-05-20T13:47:25+03:00</updated>
    <id>http://ifdattic.com/spy-test-double-using-prophecy</id>
    <content type="html"><![CDATA[<p>Spy is a test double which records its actions. After code execution you can check if interaction is as expected. You use it to make sure the method(s) was called.</p>

<p>Below is the class which has an optional dependency which is called:</p>

<p>```php
&lt;?php</p>

<p>namespace App;</p>

<p>class Questioner
{</p>

<pre><code>private $output;
private $questions = [];
private $scorer;

public function __construct(OutputInterface $output, ScorerInterface $scorer = null)
{
    $this-&gt;output = $output;
    $this-&gt;scorer = $scorer;
}

/** @return int */
public function getQuestionsCount()
{
    return 0;
}

/**
 * Save under a new name.
 *
 * @param  string $name
 * @return boolean
 */
public function saveAs($name)
{
    $saved = $this-&gt;output-&gt;save($this-&gt;questions, $name);

    if ($saved &amp;&amp; $this-&gt;scorer) {
        $this-&gt;scorer-&gt;update();
    }

    return $saved;
}
</code></pre>

<p>}
```</p>

<p>To check that the <code>update()</code> method on <code>Scorer</code> is called use the following spy test double:</p>

<p>```php
&lt;?php</p>

<p>namespace tests;</p>

<p>use App\Output;
use App\Questioner;
use App\Scorer;
use Prophecy\Argument;</p>

<p>class QuestionerTest extends \PHPUnit_Framework_TestCase
{</p>

<pre><code>// ...

/**
 * @test
 */
function score_is_updated_on_save()
{
    $outputStub = $this-&gt;prophesize(Output::CLASS);
    $outputStub-&gt;save([], Argument::type('string'))-&gt;willReturn(true);
    $scorerSpy = $this-&gt;prophesize(Scorer::CLASS);
    $questioner = new Questioner($outputStub-&gt;reveal(), $scorerSpy-&gt;reveal());

    $questioner-&gt;saveAs('any name');

    $scorerSpy-&gt;update()-&gt;shouldHaveBeenCalled();
}
</code></pre>

<p>}
```</p>

<p>This article is from the **Test doubles using Prophecy** series which is made from following articles:

* [Dummy Test Double Using Prophecy](/dummy-test-double-using-prophecy)
* [Stub Test Double Using Prophecy](/stub-test-double-using-prophecy)
* [Spy Test Double Using Prophecy](/spy-test-double-using-prophecy)
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Stub Test Double Using Prophecy]]></title>
    <link href="http://ifdattic.com/stub-test-double-using-prophecy"/>
    <updated>2015-04-23T09:11:17+03:00</updated>
    <id>http://ifdattic.com/stub-test-double-using-prophecy</id>
    <content type="html"><![CDATA[<p>Stub is the next simplest test double after the <a href="dummy-test-double-using-prophecy">Dummy</a>.</p>

<p>It doesn&rsquo;t have any expectations about the object behavior, but behaves in a specific way when put in a specific environment.</p>

<p>Below is the class under the test:</p>

<p>```php
&lt;?php</p>

<p>namespace App;</p>

<p>class Questioner
{</p>

<pre><code>private $output;
private $questions = [];

public function __construct(OutputInterface $output)
{
    $this-&gt;output = $output;
}

/** @return int */
public function getQuestionsCount()
{
    return 0;
}

/**
 * Save under a new name.
 *
 * @param  string $name
 * @return boolean
 */
public function saveAs($name)
{
    return $this-&gt;output-&gt;save($this-&gt;questions, $name);
}
</code></pre>

<p>}
```</p>

<p><code>saveAs</code> method can be tested by using a stub test double:</p>

<p>```php
&lt;?php</p>

<p>namespace tests;</p>

<p>use App\Output;
use App\Questioner;</p>

<p>class QuestionerTest extends \PHPUnit_Framework_TestCase
{</p>

<pre><code>/**
 * @test
 */
function new_questioner_has_no_questions()
{
    $outputDummy = $this-&gt;prophesize(Output::class);
    $questioner  = new Questioner($outputDummy-&gt;reveal());

    $this-&gt;assertSame(0, $questioner-&gt;getQuestionsCount());
}

/**
 * @test
 */
function questioner_is_saved_under_a_new_name()
{
    $outputStub = $this-&gt;prophesize(Output::class);
    $outputStub-&gt;save([], 'new name')-&gt;willReturn(true);
    $questioner = new Questioner($outputStub-&gt;reveal());

    $this-&gt;assertTrue($questioner-&gt;saveAs('new name'));
}
</code></pre>

<p>}
```</p>

<p>The test will pass as long as first parameter for <code>save</code> method is an empty array (<code>[]</code>) and the second parameter is <code>new name</code>. Prophecy allows you to use argument wildcards making your tests more durable. Below you can see a new test which allows any string for a name:</p>

<p>```php
&lt;?php</p>

<p>// &hellip;
use Prophecy\Argument;</p>

<p>class QuestionerTest extends \PHPUnit_Framework_TestCase
{</p>

<pre><code>// ...

/**
 * @test
 */
function questioner_is_saved_under_any_name()
{
    $outputStub = $this-&gt;prophesize(Output::class);
    $outputStub-&gt;save([], Argument::type('string'))-&gt;willReturn(true);
    $questioner = new Questioner($outputStub-&gt;reveal());

    $this-&gt;assertTrue($questioner-&gt;saveAs('any name'));
}
</code></pre>

<p>}
```</p>

<p>For the full list of arguments you can you check the code of <code>Prophecy\Argument</code> class. Here&rsquo;s some of them you might want to use in your tests:</p>

<ul>
<li><code>Argument::is($value)</code> checks that the argument is identical to a specific value</li>
<li><code>Argument::exact($value)</code> checks that the arguments matches a specific value</li>
<li><code>Argument::type($typeOrClass)</code> checks that the argument matches a specific type or class name</li>
<li><code>Argument::any()</code> matches any argument</li>
</ul>


<p>This article is from the **Test doubles using Prophecy** series which is made from following articles:

* [Dummy Test Double Using Prophecy](/dummy-test-double-using-prophecy)
* [Stub Test Double Using Prophecy](/stub-test-double-using-prophecy)
* [Spy Test Double Using Prophecy](/spy-test-double-using-prophecy)
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dummy Test Double Using Prophecy]]></title>
    <link href="http://ifdattic.com/dummy-test-double-using-prophecy"/>
    <updated>2015-03-19T16:23:51+02:00</updated>
    <id>http://ifdattic.com/dummy-test-double-using-prophecy</id>
    <content type="html"><![CDATA[<p>Dummy is the simplest test double.</p>

<p>It doesn&rsquo;t contain any logic and you use it when you need to satisfy a dependency which is not needed for functionality being tested.</p>

<p>Below is the class which has a constructor dependency:</p>

<p>```php
&lt;?php</p>

<p>namespace App;</p>

<p>class Questioner
{</p>

<pre><code>private $output;

public function __construct(OutputInterface $output)
{
    $this-&gt;output = $output;
}

public function getQuestionsCount()
{
    return 0;
}
</code></pre>

<p>}
```</p>

<p>The dependency can be satisfied by providing a dummy object:</p>

<p>```php
&lt;?php</p>

<p>namespace tests;</p>

<p>use App\Output;
use App\Questioner;</p>

<p>class QuestionerTest extends \PHPUnit_Framework_TestCase
{</p>

<pre><code>/**
 * @test
 */
function new_questioner_has_no_questions()
{
    $outputDummy = $this-&gt;prophesize(Output::class);
    $questioner  = new Questioner($outputDummy-&gt;reveal());

    $this-&gt;assertSame(0, $questioner-&gt;getQuestionsCount());
}
</code></pre>

<p>}
```</p>

<p>This article is from the **Test doubles using Prophecy** series which is made from following articles:

* [Dummy Test Double Using Prophecy](/dummy-test-double-using-prophecy)
* [Stub Test Double Using Prophecy](/stub-test-double-using-prophecy)
* [Spy Test Double Using Prophecy](/spy-test-double-using-prophecy)
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My experience with SensioLabs Symfony certification exam]]></title>
    <link href="http://ifdattic.com/my-experience-sensiolabs-symfony-certification-exam"/>
    <updated>2015-02-17T18:19:52+02:00</updated>
    <id>http://ifdattic.com/my-experience-with-sensiolabs-symfony-certification-exam</id>
    <content type="html"><![CDATA[<p>One day I check my email and see one from Fabien <em>&ldquo;Symfony turned 9 and for being one of top 100 contributors you get a free voucher.&rdquo;</em> It definitely lifted my spirits.</p>

<p>Voucher was valid for a year so I just created a calendar reminder <em>&ldquo;Learn for Symfony certificate.&rdquo;</em> Made it due sometime in Summer and more or less forgot about it. More than enough time left for it.</p>

<p>After the SymfonyCon Madrid I evaluated my career possibilities. Decided it&rsquo;s time to stop riding a dead horse and move the majority of my time working with Symfony framework. At the same time remembered the <a href="http://en.wikipedia.org/wiki/Parkinson%27s_law">Parkinson&rsquo;s Law</a>. <strong>The task will take as long as it&rsquo;s given time</strong>. Time to add the deadline. No matter how much I will learn for it, on March 1st I need to book the exam.</p>

<p>Somehow I made January &amp; February months for learning a lot of new things. Because of that I didn&rsquo;t get as much practical experience as suspected. Still <strong>made a habit of 90 minutes reading Symfony documentation for breakfast</strong>, um, tasty. This habit was mandatory!</p>

<p>The only preparation what I did was to take all the topics written in certification page and put them in a Trello card. Add items for cookbook topics, doctrine, etc. Not all are required for certification, but a good documentation is like a good book for me, so I didn&rsquo;t mind adding them. Add the links for easy access to as much of items as possible and that&rsquo;s it.</p>

<p>At first the list of about 160 items makes you take a big breath. But one check-box at a time you can see the progress.</p>

<p>This was also the <em>great chance to improve the documentation</em> (fixing typos, etc.). Changing it to the way you imagine it (changing formatting, etc.) and picking the brains of Symfony contributors (discussions in PRs, etc.).</p>

<p><em>90 minutes each day was spent making a few notes once in a while, creating pull requests, experimenting a bit</em>. On February I did some calculations and estimated that around the middle of it I should be done. It was time to register for an exam. Really wanted to do it on February 13th the Friday (how cool does that sound). But the place I like staying at wasn&rsquo;t available for rent. Also it felt like trying to avoid the unavoidable (a bad habit to have). So just registered for Monday (the sooner the better).</p>

<p>In the remaining days finished with the remaining topics. Did a <em>quick second round on the book</em> and it was time to take the exam the next day. <em>This took me about 6 weeks (~63 hours)</em>. I never believed about learning till the last second. My choice always is to put a good nights sleep between learning &amp; applying it. So Sunday documentation breakfast was the last one I will be taking for at least a while (<em>failure is always an option</em>).</p>

<p>The next day I woke up feeling great. Slept well, had a nice meeting the day before, exercised, took a shower, ate and the day looked like it will be a great one. Or would it? Nah, it would be a good one. The worst that could happen is that I won&rsquo;t pass the exam and that&rsquo;s it. It&rsquo;s not the end of a world.</p>

<p>OK, I worried a bit about slipping on the icy bridge while walking to the exam center and breaking my neck or dropping into a cold water. But this is the problem with my imagination. Other than that, I was trying to keep a relaxed attitude by taking a long slow walk along the snowed river to the exam center. Went out early to keep my paranoia in check about arriving late, <em>I like to stay safe</em>.</p>

<p>It sounds silly, but after arriving <em>I noticed my legs getting a bit weaker and heart pounding a little harder. Stupid body</em>. Had about half an hour before the exam. I always try to prepare myself for the worst scenario (which never happens) just in case. And you get a pleasant surprise when the end result is better than that you were expecting. If you&rsquo;re prepared to lose both legs, losing only one of them is wonderful. But most of the time from my research (books, articles, etc.) the suggestion is to imagine the result you want and your mind will go towards it. I&rsquo;m still skeptic about it, but if it&rsquo;s repeated often there must be something to it. And <em>you can&rsquo;t learn without testing</em>, so why not, let&rsquo;s try it.</p>

<p>I sat down. Closed my eyes. Started taking monotonic breaths and focusing my mind on passing the exam. At least my heart stopped pounding. A fresher head couldn&rsquo;t hurt either.</p>

<p><em>I&rsquo;m personally a little skeptic about these exams as you could pass them with a good memory</em>. Especially after I met a person with a Java certificate when he shouldn&rsquo;t be a programmer in the first place. Unfortunately for me, <em>I  don&rsquo;t have a good memory, and it works in strange ways</em>. For example, trying to remember when I had my first operation (string of 10 characters) leads to the following flow: it was on my birthday, I finished school that year, it was my 19th birthday, I finished school one year after 18th birthday, on my school leaving certificate it&rsquo;s written 2006, so I had it on 2006-06-28. Not the best way to remember a date. <em>Fortunately for me, my logic module pick up the pace and helps were memory starts ramble. I just have to put enough resources to be able to link them together.</em></p>

<p>By reminding myself that it wouldn&rsquo;t matter if I fail my head wasn&rsquo;t occupied by negative thoughts about that will happen if I fail. This allowed to take the exam with <em>stone cold focus. Read the question, read the answers, pick the one which is correct or makes most sense, keep going</em>. Flagged two questions for review, but after the second time told myself to stop doing that and simply believe in myself. <em>I enjoyed the exam a lot. It had a good flow &amp; presentation of questions</em>. A few of them made my head go &ldquo;What??&rdquo; (unlike Zend Certificate which contained quite a few &ldquo;WTF?!?&rdquo; questions). Solution to them was simple &ndash; read the question &amp; answers again, you can do this.</p>

<p>75 questions later was confirming that I&rsquo;m finishing the exam and the moment of truth&hellip; Thinking I did good on exam. Still, took the big breath guessing if I should just wait for screen to change or close my eyes&hellip; The screen is still waiting&hellip; The screen finishes loading&hellip; And a log-in pop-up shoots to the front of the screen&hellip;</p>

<p>(╯°□°）╯︵ ┻━┻</p>

<p>After some fiddling I bring the screen back. My eyes start shooting around the screen scanning for required information. &hellip; &ldquo;<strong>Passed</strong>.&rdquo; Great, which level? &hellip; &ldquo;<strong>Expert</strong>.&rdquo; Yes *fist pump*</p>

<p>Unlike with PHP certificate my reaction at the end of exam was much more &ldquo;professional.&rdquo; It still felt awesome!!!</p>

<p>Note: For anyone who is interested I made a <a href="https://trello.com/c/aHnP3WUI/1-learn-for-symfony-certification">Trello card</a> public.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to use MongoDB & NodeJS with Docker (video included)]]></title>
    <link href="http://ifdattic.com/how-to-mongodb-nodejs-docker"/>
    <updated>2015-01-09T19:29:10+02:00</updated>
    <id>http://ifdattic.com/how-to-mongodb-nodejs-docker</id>
    <content type="html"><![CDATA[<p>This is the short intro on how to use spin up MongoDB and NodeJS containers using Docker. This will take you step by step on how to run those containers, some problems you might run into, how to avoid some pitfalls. After it you will have enough experience on working with Docker, MongoDB &amp; NodeJS. It will provide enough foundation to use those technologies and will give a head start if you will want to learn more. Initial intent was to use it for MongDB course from MongoDBUniversity, but it was reworked for general use. Part of the tutorial will provide tips on how to use it with the mentioned course.</p>

<p><del datetime="2015-01-27">A few months ago a friend mentioned a <a href="https://university.mongodb.com/courses/M101JS/about">MongoDB course from MongoDBUniversity</a>, which sounded like a lot of fun so of course I enrolled into it. It started a few days ago and it&rsquo;s a lot of fun. As I like to keep my OS clean the Docker looked like a great solution (one of the reasons I like it, just do something and throw it away after you&rsquo;re done, just like with cloud computing). This way I could take three rabbits with one shot learning <a href="http://www.mongodb.org/">MongoDB</a>, <a href="http://nodejs.org/">Node.js</a> and <a href="https://www.docker.com/">Docker</a> at the same time.</del></p>

<p><del datetime="2015-01-27">I just noticed that because I had to figure some things to make it all work this can be a great opportunity for an article to help my fellow companions with this step.</del></p>

<p>Please note that I&rsquo;m using Mac OS so you might need to adjust examples to your OS and/or user. Please use the <a href="https://docs.docker.com/installation/#installation">installation instructions</a> to launch the docker on your machine.</p>

<h2>MongoDB</h2>

<p>First get the latest <a href="https://registry.hub.docker.com/_/mongo/">mongo image</a>:</p>

<p><code>bash
docker pull mongo:latest
</code></p>

<p>And when launch your MongoDB container:</p>

<p><code>bash
docker run -v "$(pwd)":/data --name mongo -d mongo mongod --smallfiles
</code></p>

<p>The current directory you&rsquo;re running this command from will be used as data directory in your container (provided by <code>$(pwd)</code>). Change it if you need to by entering the full path.</p>

<p>The running containers can be checked by:</p>

<p>```bash</p>

<h1>display only running containers</h1>

<p>docker ps</p>

<h1>or if you want all containers displayed</h1>

<p>docker ps -a
```</p>

<p>There are two options for connecting to your Mongo database.</p>

<p>```bash
docker run -it \</p>

<pre><code>--link mongo:mongo \
--rm mongo sh \
-c 'exec mongo "$MONGO_PORT_27017_TCP_ADDR:$MONGO_PORT_27017_TCP_PORT/test"'
</code></pre>

<h1>or on one line for easier copy-paste</h1>

<p>docker run -it &mdash;link mongo:mongo &mdash;rm mongo sh -c &lsquo;exec mongo &ldquo;$MONGO_PORT_27017_TCP_ADDR:$MONGO_PORT_27017_TCP_PORT/test&rdquo;&rsquo;
```</p>

<p>This will create a new mongo container which is linked with an existing mongo container. After container is created the command which connects to database is executed.</p>

<p>Personally, I like just connecting to a running container and executing needed commands from it. You can do what with:</p>

<p>```bash
docker exec -it 442c2541fe1a bash # by ID</p>

<h1>or</h1>

<p>docker exec -it mongo bash # by Name
```</p>

<p>To test that your mongo database is working execute the following commands from mongo container:</p>

<p><code>bash
mongo
db.col.insert({"a": 4})
db.col.find().pretty()
</code></p>

<p>The new document should have been inserted and displayed back to you. You Mongo database is up and ready to be used in your projects.</p>

<h3>Dump and restore the database</h3>

<p>Please note that depending on your set up the database files might not be synced with your host OS. You can check this by listing the files of database directory:</p>

<p><code>bash
ls -la db
</code></p>

<p>If it&rsquo;s empty then database files are not synced.</p>

<p>If the data you have in your database is important and you don&rsquo;t want to lose it export it before removing your container (stopping the container will preserve the files).</p>

<p>Please check the documentation or <code>--help</code> output for more information, but to do a simple export run the following from the container (export <code>test</code> database to <code>/data/test-backup</code> destination):</p>

<p><code>bash
mongodump --db test --out /data/test-backup
</code></p>

<p>Your data directory (from the container) should now contain the backup files and it should be synced with your host OS.</p>

<p>To restore the data run the following from container (restore <code>/data/test-backup/test/</code> into a <code>test-restored</code> database):</p>

<p><code>bash
mongorestore --db test-restored /data/test-backup/test
</code></p>

<h2>Node.js</h2>

<p>First get the latest <a href="https://registry.hub.docker.com/_/node/">node image</a>:</p>

<p><code>bash
docker pull node:latest
</code></p>

<p>To launch the NodeJS container run:</p>

<p><code>bash
docker run -it --rm node
</code></p>

<p>This will run the node container and will put you in the interactive shell (REPL) from which you can execute code. You can test it by entering:</p>

<p><code>bash
console.log('It works!!')
</code></p>

<p>To exit the interactive shell and remove the container (as it contains <code>--rm</code> option) press <code>Control+C</code> twice.</p>

<p>You have multiple ways of running your NodeJS applications. One which I personally like (especially for MongoDB course) is to create a container which has all the required data mounted and is linked to mongo container. This allows to run multiple applications without having to create new containers. It also exposes the port to host machine so you could open the application in your browser. If you want you can set working directory with <code>-w</code> option.</p>

<p><code>bash
docker run -it --name node -v "$(pwd)":/data --link mongo:mongo -w /data -p 8082:8082 node bash
</code></p>

<p>Now to run the application just enter its directory, install dependencies and run front controller script:</p>

<p>```bash</p>

<h1>execute commands in container</h1>

<p>cd hw3-2and3-3/blog
npm install
node app.js
```</p>

<p>If you&rsquo;re running these examples with MongoDB course examples it will fail. This is because it&rsquo;s trying to connect to Mongo database on localhost, but our Mongo database isn&rsquo;t on local machine. There are multiple ways to fix this:</p>

<ul>
<li>hard code the connection string (with linked container IP);</li>
<li>use environment variables which are added automatically by Docker (when linking);</li>
<li>use hosts entry which is added automatically by Docker (when linking).</li>
</ul>


<p>Example below contains the representation of all those methods. Please choose the one which you like most or is best for your use case.</p>

<p>```javascript
// Original connect
MongoClient.connect(&lsquo;mongodb://localhost:27017/blog&rsquo;, function(err, db) {</p>

<pre><code>// ...
</code></pre>

<p>});</p>

<p>// Connect using environment variables
MongoClient.connect(&lsquo;mongodb://&rsquo;+process.env.MONGO_PORT_27017_TCP_ADDR+&lsquo;:&rsquo;+process.env.MONGO_PORT_27017_TCP_PORT+&lsquo;/blog&rsquo;, function(err, db) {</p>

<pre><code>// ...
</code></pre>

<p>});</p>

<p>// Connect using hosts entry
MongoClient.connect(&lsquo;mongodb://mongo:27017/blog&rsquo;, function(err, db) {</p>

<pre><code>// ...
</code></pre>

<p>});
```</p>

<p>After fixing the <code>connect()</code> method the application should run successfully. You can reach it by opening <code>http://192.168.59.103:8082</code> (if it was IP address of your Docker application) or if you added the Docker IP as <code>docker</code> in your hosts file <code>http://docker:8082</code>.</p>

<p>To exit your application press <code>Control-C</code></p>

<p>It&rsquo;s also possible to run the application in container directly.</p>

<p>```bash</p>

<h1>from host OS terminal</h1>

<p>docker run \</p>

<pre><code>--name nodeapp \
-v "$(pwd)":/data \
--link mongo:mongo \
-w /data/hw3-2and3-3/blog \
-p 8082:8082 \
-d node node app.js
</code></pre>

<h1>or on one line for easy copy-paste</h1>

<p>docker run &mdash;name nodeapp -v &ldquo;$(pwd)&rdquo;:/data &mdash;link mongo:mongo -w /data/hw3-2and3-3/blog -p 8082:8082 -d node node app.js
```</p>

<p>The following commands might be useful when running containers as daemons (replace <code>nodeapp</code> with ID or name of container):</p>

<p>```bash</p>

<h1>to see running containers</h1>

<p>docker ps</p>

<h1>to check output of container</h1>

<p>docker logs nodeapp</p>

<h1>to tail the output of container</h1>

<p>docker logs -f nodeapp</p>

<h1>to stop running container</h1>

<p>docker stop nodeapp
```</p>

<h2>MongoDB Course Manual Validation Tips</h2>

<p>If you using this for MongoDB University course and chose to do manual validation (haven&rsquo;t tested with MongoProc validation) you will need to keep a few things in your mind.</p>

<p>For second week second homework it&rsquo;s not possible to configure the validation script and it tries to connect to Mongo database which is on localhost. To fix this open your <code>/etc/hosts</code> file (you might need to install some editor on your container), enter the <code>MONGOIP localhost</code> as the first entry (<strong>replace <code>MONGOIP</code> with mongo container IP address, should be in the same hosts file</strong>) and comment out the real <code>localhost</code> entry. Now running validation script should succeed and you should receive the validation code if you did homework assignment correctly. <strong>Don&rsquo;t forget to revert the changes to <code>/etc/hosts</code> file!!!</strong></p>

<p>Other assignment validation is simpler as it allows to configure the validation script. Run validation with <code>--help</code> to see what is available for configuration. The defaults for web server should be correct (as you should have one container and two terminals for it, one running the application, another executing validation) you only need to change connection string for Mongo database. Enter the following to validate third week second assignment:</p>

<p><code>bash
node hw3-2validate.js --db mongodb://mongo:27017/blog
</code></p>

<p>If you done your homework correctly you should receive the validation code.</p>

<h2>Conclusion</h2>

<p>Now you should have enough knowledge to be able to run MongoDB and NodeJS using Docker. You can take most of that knowledge and expand it to other containers even if you don&rsquo;t want to learn more about Docker. This would still provide you with ability to rapidly test your ideas and throw away the resources as needed.</p>

<p>If you&rsquo;re using this for MongoDB University course it should help with most of the issues you could run while completing your assignments.</p>

<p>If you&rsquo;re willing to hurt your ears by listening to my voice you can find the screen cast of this whole tutorial at <a href="https://www.youtube.com/playlist?list=PLOyuTJZcQNNDSVMlAkIEoPX9CDrOGyTVt">YouTube</a>. If you&rsquo;re listening on mute or can&rsquo;t understand what I&rsquo;m saying the <a href="scripts/screencast-how-to-mongo-node-docker">script for screen cast is available</a>.</p>

<p>If you have any questions, suggestions or any part of it is unclear please leave a comment.</p>
]]></content>
  </entry>
  
</feed>
