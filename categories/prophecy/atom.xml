<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Prophecy | ifdattic]]></title>
  <link href="http://ifdattic.com/categories/prophecy/atom.xml" rel="self"/>
  <link href="http://ifdattic.com/"/>
  <updated>2015-04-24T14:47:45+03:00</updated>
  <id>http://ifdattic.com/</id>
  <author>
    <name><![CDATA[Andrew MarcinkeviÄius]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Stub Test Double Using Prophecy]]></title>
    <link href="http://ifdattic.com/stub-test-double-using-prophecy"/>
    <updated>2015-04-23T09:11:17+03:00</updated>
    <id>http://ifdattic.com/stub-test-double-using-prophecy</id>
    <content type="html"><![CDATA[<p>Stub is the next simplest test double after the <a href="dummy-test-double-using-prophecy">Dummy</a>.</p>

<p>It doesn&rsquo;t have any expectations about the object behavior, but behaves in a specific way when put in a specific environment.</p>

<p>Below is the class under the test:</p>

<p>```php
&lt;?php</p>

<p>namespace App;</p>

<p>class Questioner
{</p>

<pre><code>private $output;
private $questions = [];

public function __construct(OutputInterface $output)
{
    $this-&gt;output = $output;
}

/** @return int */
public function getQuestionsCount()
{
    return 0;
}

/**
 * Save under a new name.
 *
 * @param  string $name
 * @return boolean
 */
public function saveAs($name)
{
    return $this-&gt;output-&gt;save($this-&gt;questions, $name);
}
</code></pre>

<p>}
```</p>

<p><code>saveAs</code> method can be tested by using a stub test double:</p>

<p>```php
&lt;?php</p>

<p>namespace tests;</p>

<p>use App\Output;
use App\Questioner;</p>

<p>class QuestionerTest extends \PHPUnit_Framework_TestCase
{</p>

<pre><code>/**
 * @test
 */
function new_questioner_has_no_questions()
{
    $outputDummy = $this-&gt;prophesize(Output::class);
    $questioner  = new Questioner($outputDummy-&gt;reveal());

    $this-&gt;assertSame(0, $questioner-&gt;getQuestionsCount());
}

/**
 * @test
 */
function questioner_is_saved_under_a_new_name()
{
    $outputStub = $this-&gt;prophesize(Output::class);
    $outputStub-&gt;save([], 'new name')-&gt;willReturn(true);
    $questioner = new Questioner($outputStub-&gt;reveal());

    $this-&gt;assertTrue($questioner-&gt;saveAs('new name'));
}
</code></pre>

<p>}
```</p>

<p>The test will pass as long as first parameter for <code>save</code> method is an empty array (<code>[]</code>) and the second parameter is <code>new name</code>. Prophecy allows you to use argument wildcards making your tests more durable. Below you can see a new test which allows any string for a name:</p>

<p>```php
&lt;?php</p>

<p>// &hellip;
use Prophecy\Argument;</p>

<p>class QuestionerTest extends \PHPUnit_Framework_TestCase
{</p>

<pre><code>// ...

/**
 * @test
 */
function questioner_is_saved_under_any_name()
{
    $outputStub = $this-&gt;prophesize(Output::class);
    $outputStub-&gt;save([], Argument::type('string'))-&gt;willReturn(true);
    $questioner = new Questioner($outputStub-&gt;reveal());

    $this-&gt;assertTrue($questioner-&gt;saveAs('any name'));
}
</code></pre>

<p>}
```</p>

<p>For the full list of arguments you can you check the code of <code>Prophecy\Argument</code> class. Here&rsquo;s some of them you might want to use in your tests:</p>

<ul>
<li><code>Argument::is($value)</code> checks that the argument is identical to a specific value</li>
<li><code>Argument::exact($value)</code> checks that the arguments matches a specific value</li>
<li><code>Argument::type($typeOrClass)</code> checks that the argument matches a specific type or class name</li>
<li><code>Argument::any()</code> matches any argument</li>
</ul>


<p>This article is from the **Test doubles using Prophecy** series which is made from following articles:

* [Dummy Test Double Using Prophecy](/dummy-test-double-using-prophecy)
* [Stub Test Double Using Prophecy](/stub-test-double-using-prophecy)
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dummy Test Double Using Prophecy]]></title>
    <link href="http://ifdattic.com/dummy-test-double-using-prophecy"/>
    <updated>2015-03-19T16:23:51+02:00</updated>
    <id>http://ifdattic.com/dummy-test-double-using-prophecy</id>
    <content type="html"><![CDATA[<p>Dummy is the simplest test double.</p>

<p>It doesn&rsquo;t contain any logic and you use it when you need to satisfy a dependency which is not needed for functionality being tested.</p>

<p>Below is the class which has a constructor dependency:</p>

<p>```php
&lt;?php</p>

<p>namespace App;</p>

<p>class Questioner
{</p>

<pre><code>private $output;

public function __construct(OutputInterface $output)
{
    $this-&gt;output = $output;
}

public function getQuestionsCount()
{
    return 0;
}
</code></pre>

<p>}
```</p>

<p>The dependency can be satisfied by providing a dummy object:</p>

<p>```php
&lt;?php</p>

<p>namespace tests;</p>

<p>use App\Output;
use App\Questioner;</p>

<p>class QuestionerTest extends \PHPUnit_Framework_TestCase
{</p>

<pre><code>/**
 * @test
 */
function new_questioner_has_no_questions()
{
    $outputDummy = $this-&gt;prophesize(Output::class);
    $questioner  = new Questioner($outputDummy-&gt;reveal());

    $this-&gt;assertSame(0, $questioner-&gt;getQuestionsCount());
}
</code></pre>

<p>}
```</p>

<p>This article is from the **Test doubles using Prophecy** series which is made from following articles:

* [Dummy Test Double Using Prophecy](/dummy-test-double-using-prophecy)
* [Stub Test Double Using Prophecy](/stub-test-double-using-prophecy)
</p>
]]></content>
  </entry>
  
</feed>
